package Companylib

import (
	"context"
	"fmt"
	"log"

	"github.com/aws/aws-sdk-go-v2/aws"

	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	dynamodb_types "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"

	dynamodb_attributevalue "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"

	awsclients "github.com/busyfit-admin/saas-integrated-apis/lambdas/lib/clients"
)

const (
	CARD_ISACTIVE_FALSE   = "INACTIVE"
	CARD_ISACTIVE_TRUE    = "ACTIVE"
	CARD_ISACTIVE_EXPIRED = "EXPIRED"
	CARD_ISREDEEMED       = "REDEEMED"
)

type CompanyCards struct {
	CardNumber string `dynamodbav:"CardNumber" json:"CardNumber"` // Unique CardId/ Card Number 00009
	CardId     string `dynamodbav:"CardId" json:"CardId"`         // Ref to CardMetaDataId

	CardType string `dynamodbav:"CardType" json:"CardType"` // Card Type that is selected ( card type can be of either : general, health, climate rewards)

	CardStatus string `dynamodbav:"CardStatus" json:"CardStatus"` // Status of the Card (ACTIVE, INACTIVE, EXPIRED, REDEEMED)

	RedeemedBy string `dynamodbav:"RedeemedBy" json:"RedeemedBy"` // Ref to EmployeeId
	RedeemedOn string `dynamodbav:"RedeemedOn" json:"RedeemedOn"` // Date on which the card is redeemed
}

type CompanyCardsService struct {
	ctx            context.Context
	logger         *log.Logger
	dynamodbClient awsclients.DynamodbClient

	CompanyCardsTable         string // All Cards Table generated by the Tenant
	CompanyCardsMetadataTable string // All Cards meta data Table generated by the Tenant

	// This is for the transaction related things
	RewardsTransferLogsTable string // All Rewards Transfer Logs Table generated by the Tenant

	CardId_Status_Index string // Index on the CardId and Status of the Cards Table
	CardType_Index      string // Index on the CardType of the Cards Meta Data Table

	EmployeeTable string // All Employees Table generated by the Tenant

}

func CreateCompanyCardsService(ctx context.Context, logger *log.Logger, ddbClient awsclients.DynamodbClient) *CompanyCardsService {
	return &CompanyCardsService{
		ctx:            ctx,
		logger:         logger,
		dynamodbClient: ddbClient,
	}
}

// 1. Get the count of all the Active Cards by CardType along with the Card MetaData
/*
Cards Meta Data table:
	CardId string `dynamodbav:"CardId" json:"CardId"` // PK, Unique Identifier for the Card
	// Card Type that is selected ( card type can be of either : general, health, climate rewards). These can be only 4 types. ( RD00, RD01, RD02, RD03)
	// Ref Employee's Table for the CardType
	CardType string `dynamodbav:"CardType" json:"CardType"` // Sort Key, Card Type of the Card

	CardName string `dynamodbav:"CardName" json:"CardName"` // Custom name of the card that is entered by the Tenant
	CardDesc string `dynamodbav:"CardDesc" json:"CardDesc"` // Custom description of the card that is entered by the Tenant

	CardImages []string `dynamodbav:"CardImages" json:"CardImages"` // Card Images that are uploaded. Key is the image number and value is the image URL
	CardCost   float64  `dynamodbav:"CardCost" json:"CardCost"`     // Cost of the Card in Dollars

	Validity int `dynamodbav:"Validity" json:"Validity"` // Validity of the Card in days

	TermsAndConditions string `dynamodbav:"TermsAndConditions" json:"TermsAndConditions"` // Terms and Conditions of the Card

	RedemptionLogic string `dynamodbav:"RedemptionLogic" json:"RedemptionLogic"` // Redemption Logic of the Card , 2 Values are possible : Auto or Manual



	expected Response for the Cards Checkout Page:
	{
		"Health": {
			[
				{
					"CardCount" : 10,
					"CardMetaData" : {
						"CardId" : "123",
						"CardType" : "Health",
						"CardName" : "Health Card",
						"CardDesc" : "Health Card Description",
						"CardImages" : ["https://image1.jpg", "https://image2.jpg"],
						"CardCost" : 10.0,
						"Validity" : 30,
						"TermsAndConditions" : "T&C",
						"RedemptionLogic" : "Auto"
					},


				},
				{
					"CardCount" : 10,
					"CardMetaData" : {
						"CardId" : "123",
						"CardType" : "Health",
						"CardName" : "Health Card",
						"CardDesc" : "Health Card Description",
						"CardImages" : ["https://image1.jpg", "https://image2.jpg"],
						"CardCost" : 10.0,
						"Validity" : 30,
						"TermsAndConditions" : "T&C",
						"RedemptionLogic" : "Auto"
					},


				}
			]
			},
			"WFH": {
				....
			},
	}

	1. Query the Cards Meta Data Table for each Card Type, and get the list of Card Meta Data. ( Sign the URLS of the Card Images )
	       - For each Card Meta Data, query the Cards Table to get the count of Active Cards.

	2. Return the Response in the expected format.
*/

func (svc *CompanyCardsService) GetCardCountByIdAndStatus(cardId string, status string) int32 {

	if cardId == "" {
		svc.logger.Printf("Failed to find the CardID : %v", cardId)
		return 0
	}

	var count int32
	count = 0

	queryInput := dynamodb.QueryInput{
		TableName:              aws.String(svc.CompanyCardsTable),
		IndexName:              aws.String(svc.CardId_Status_Index),
		KeyConditionExpression: aws.String("CardId = :CardId AND CardStatus = :CardStatus"),
		ExpressionAttributeValues: map[string]dynamodb_types.AttributeValue{
			":CardId":     &dynamodb_types.AttributeValueMemberS{Value: cardId},
			":CardStatus": &dynamodb_types.AttributeValueMemberS{Value: status},
		},
	}

	output, err := svc.dynamodbClient.Query(svc.ctx, &queryInput)
	if err != nil {
		svc.logger.Printf("Failed to Query on the Cards Table: %v, with CardId: %v, err: %v ", svc.CompanyCardsTable, cardId, err)
		return 0
	}

	count = output.Count

	return count

}

type CardMetaDataOutputWithCount struct {
	CardCount    int                       `json:"CardCount"`
	CardMetaData CompanyCardsMetaDataTable `json:"CardMetaData"`
}

func (svc *CompanyCardsService) GetCardsByType(CardType string) ([]CardMetaDataOutputWithCount, error) {

	if CardType == "" {
		return nil, fmt.Errorf("CardType cannot be empty for GetCardsByType")
	}

	queryInput := dynamodb.QueryInput{
		TableName:              aws.String(svc.CompanyCardsMetadataTable),
		IndexName:              aws.String(svc.CardType_Index),
		KeyConditionExpression: aws.String("CardType = :CardType"),
		ExpressionAttributeValues: map[string]dynamodb_types.AttributeValue{
			":CardType": &dynamodb_types.AttributeValueMemberS{Value: CardType},
		},
	}

	output, err := svc.dynamodbClient.Query(svc.ctx, &queryInput)
	if err != nil {
		return nil, err
	}

	var CardMetaData []CardMetaDataOutputWithCount
	var Cards []CompanyCardsMetaDataTable
	err = dynamodb_attributevalue.UnmarshalListOfMaps(output.Items, &Cards)
	if err != nil {
		svc.logger.Printf("Unmarshal on the CardMetaData Failed :%v", err)
		return nil, err
	}

	for _, card := range Cards {
		cardCount := svc.GetCardCountByIdAndStatus(card.CardId, CARD_ISACTIVE_TRUE)
		CardMetaData = append(CardMetaData, CardMetaDataOutputWithCount{
			CardCount:    int(cardCount),
			CardMetaData: card,
		})
	}

	return CardMetaData, nil
}

// Cards Checkout Logic
/*
	1. Get the Card Meta Data by CardId
		If CardMetaData is not found or status is not Active, Go to Step 7.
	2. Get the Card Count by CardId and Status
		if CardCount >0:
			 Proceed to Step 7

	3. Check if the Employee has enough points to redeem the Card.
		Points Calculation Logic.

	4. Create a TransactionId for the Transaction. Enter in the RewardsTransferLogsTable

	5. Start the Transaction.
		- Update the Card Status to Redeemed, RedeemedBy and RedeemedOn in the Card Table
		- Update the Employee's Points in the Employee's Table and Add the Card to the Employee's Redeemed Cards List
		- Update the Transaction Status to Success in the RewardsTransferLogsTable
		- Commit the Transaction

	6. Return the Response in the successful Transaction expected format

	7. Return the Response in the failed Transaction expected format

*/

func (svc *CompanyCardsService) GetCardDataByIdAndStatus(cardId string, status string) ([]CompanyCards, error) {

	if cardId == "" {
		return nil, fmt.Errorf("CardId cannot be empty for GetCardDataByIdAndStatus")
	}

	var cardData []CompanyCards

	queryInput := dynamodb.QueryInput{
		TableName:              aws.String(svc.CompanyCardsTable),
		IndexName:              aws.String(svc.CardId_Status_Index),
		KeyConditionExpression: aws.String("CardId = :CardId AND CardStatus = :CardStatus"),
		ExpressionAttributeValues: map[string]dynamodb_types.AttributeValue{
			":CardId":     &dynamodb_types.AttributeValueMemberS{Value: cardId},
			":CardStatus": &dynamodb_types.AttributeValueMemberS{Value: status},
		},
	}

	output, err := svc.dynamodbClient.Query(svc.ctx, &queryInput)
	if err != nil {
		return nil, err
	}

	err = dynamodb_attributevalue.UnmarshalListOfMaps(output.Items, &cardData)
	if err != nil {
		svc.logger.Printf("Unmarshal on the CardMetaData Failed :%v", err)
		return nil, err
	}

	return cardData, err
}

func (svc *CompanyCardsService) GetCardsDataForCheckout(cardId string) (CompanyCards, error) {

	if cardId == "" {
		return CompanyCards{}, fmt.Errorf("CardId cannot be empty for CheckoutCard")
	}

	// Get the Card Count by CardId and Status
	cards, err := svc.GetCardDataByIdAndStatus(cardId, CARD_ISACTIVE_TRUE)
	if err != nil {
		return CompanyCards{}, err
	}

	if len(cards) == 0 {
		return CompanyCards{}, fmt.Errorf("No Active Cards found for the CardId")
	}

	// Check if the Employee has enough points to redeem the Card.
	// Points Calculation Logic.

	// Create a TransactionId for the Transaction. Enter in the RewardsTransferLogsTable (done)

	// Start the Transaction.
	// Update the Card Status to Redeemed, RedeemedBy and RedeemedOn in the Card Table (done)
	// Update the Employee's Points in the Employee's Table and Add the Card to the Employee's Redeemed Cards List (partial)
	// Update the Transaction Status to Success in the RewardsTransferLogsTable
	// Commit the Transaction

	// Return the Response in the successful Transaction expected format

	return cards[0], nil
}
